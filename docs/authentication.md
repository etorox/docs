# eToroX Authentication

At eToroX we value the security of our clients very highly.

At each authenticated end-point, users need to verify their identity. This authentication process was created to ensure that no userâ€™s identity can be stolen or forged.

> Do not share your private keys! eToroX will never ask you to share or send your private keys.


## Authenticated end-points
eToroX currently provides two communications modes, both  with different interfaces, but sharing the same authentication processes and properties.

Authenticated end-points:
* [HTTPS authentication](https-api)
* [Websockets authentication](websockets-api)


## Access to eToroX API
Access to eToroX API is only permitted for verified users.  Verified developer app users can manage their *developer app API tokens* from the website UI.

### Developer APP
The `Developer app` enables access to the eToroX API.

Every `developer app` provides the following information:
* HTTPS API - A private DNS for https access.
* WebSockets - A private DNS for websocket access. The properties are accessible from the trading API settings section on the website

*Requests for developer apps are currently individually reviewed by Customer Support, and manually approved.*

### API tokens
`API tokens` are generated based on the `developer app`. Users can manage multiple `API tokens`, by identifying each `API token` with a customized token name.
When tokens are generated, the following information becomes accessible:
* API key - A UUID id of this token.
* Private Key - A private key used for signing.
*Important! This information cannot be retrieved and must be stored by the user*

## Benefits of Authentication Process
* Access to API granted by creating specific `API tokens`.
* `API token` can only be created with two factor authentication (2FA) and verification.
* `API token` data are only available during creation.
* `API token` credentials are comprised of an asymmetric RSA private/public pair of keys.
* During `API token` creation the user  receives a private key to sign data.
* eToroX stores only the asymmetric public key. Even if a user has `Read Access` to our servers, this information is completely inaccessible, and user identities cannot be forged. 
* As part of the authentication process, eToroX mitigates "man-in-the-middle" attacks using a combination of TLS encryption, a timestamp and nonce (Number Only Used Once) validations with asymmetric signature signing. Note: Sensitive information should NEVER be passed in API communication.
* As part of the authentication process, eToroX mitigates replay attacks by verifying both nonce and timestamp verifications.
* `API tokens` permissions can be scoped when created. Scoping ensures that a token is only used for specific actions.
* `API token` details are immutable. They can always be deleted, but never modified or retrieved.

## Authentication process
The authentication process requires the following parameters:
* API key - A UUID identifies this token
* Private key - An asymmetric RSA private key that should never be shared
* Timestamp - Number of milliseconds since epoch of the moment the signature was created (example: 1567334955567)
* Nonce - A UUID

eToroX servers verifies user identity based on the following:
* API key
* Signature For details about creating a signature, see the following section
* Nonce
* Timestamp

### Create a signature
Asymmetric signatures are generated by the user to prove to the eToroX server that the user has access to their own private keys. eToroX then confirms this by running a similar but asymmetric process with the public key equivalent.
The following parameters are used for signature generation:
* API key
* Private key
* Nonce
* Milliseconds since epoch

#### Private key
The private keys generated by eToroX are:
* `PKCS8` encoded.
* `PEM` formatted.
* Cipher `AES-256-CBC`
* Empty string as the passphrase `` .

*Some libraries may require the user to convert the private key into different encoding. This can be done by using the `openssl` command line tool.*

#### Signing process

The payload the user signs is a concatenation of the `nonce` and `milliseconds since epoch`.
```js
const payload = `${nonce}${timestamp}`;
```

The payload should be signed with a `SHA256` signature algorithm and result should be `base64` encoded.

```js
const payload = `${nonce}${timestamp}`;
const signer = crypto.createSign('sha256');
signer.update(payload);
signature = signer.sign({key: privateKey , passphrase : ''}, 'base64');
```

### Troubleshooting

* [Example of dummy signature process ](https://gist.github.com/etorox/457009e1e02bdf878225da09fdb64acf)
* [Convert pkcs8 to pkcs1 using openssl native](https://gist.github.com/etorox/094eb6d22cf83d72218d2d28ff304bc4)
